import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { verifyToken } from '@/lib/auth';
import { format } from 'date-fns';
import * as XLSX from 'xlsx';

export async function GET(request: NextRequest) {
  try {
    const token = request.cookies.get('token')?.value;

    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const payload = verifyToken(token);
    if (!payload) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 });
    }

    // Get query parameters
    const searchParams = request.nextUrl.searchParams;
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');
    const status = searchParams.get('status');
    const partyId = searchParams.get('partyId');
    const exportFormat = searchParams.get('format') || 'excel';

    // Build where clause based on user role and filters
    const whereClause: any = {};

    // Role-based filtering - Department-wide visibility
    if (payload.role === 'AREA_OFFICE') {
      // Area office can see all DOs at their stage
      whereClause.status = {
        in: ['created', 'at_area_office']
      };
    } else if (payload.role === 'PROJECT_OFFICE') {
      // Project office can see all DOs at their stage and beyond
      whereClause.status = {
        in: ['at_project_office', 'received_at_project_office', 'at_road_sale']
      };
    } else if (payload.role === 'CISF') {
      // CISF can see all DOs that need their approval or have been approved by them
      whereClause.OR = [
        { status: { in: ['at_project_office', 'received_at_project_office'] } },
        { cisfApproved: true }
      ];
    } else if (payload.role === 'ROAD_SALE') {
      // Road Sale can see all DOs at their stage
      whereClause.status = 'at_road_sale';
    }
    // Admin can see all (no filter added)

    // Date range filter
    if (startDate && endDate) {
      whereClause.createdAt = {
        gte: new Date(startDate),
        lte: new Date(endDate + 'T23:59:59.999Z')
      };
    }

    // Status filter
    if (status && status !== 'all') {
      whereClause.status = status;
    }

    // Party filter
    if (partyId && partyId !== 'all') {
      whereClause.partyId = partyId;
    }

    // Fetch delivery orders
    const deliveryOrders = await prisma.deliveryOrder.findMany({
      where: whereClause,
      include: {
        party: true,
        createdBy: {
          select: {
            username: true,
            email: true,
          }
        },
        issues: {
          include: {
            reportedBy: {
              select: {
                username: true,
              }
            }
          }
        },
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    if (exportFormat === 'excel') {
      return exportToExcel(deliveryOrders, payload);
    } else {
      return exportToPDF(deliveryOrders, payload);
    }
  } catch (error) {
    console.error('Error exporting report:', error);
    return NextResponse.json(
      { error: 'Failed to export report' },
      { status: 500 }
    );
  }
}

function exportToExcel(deliveryOrders: any[], user: any) {
  // Prepare data for Excel
  const excelData = deliveryOrders.map(order => ({
    'DO Number': order.doNumber,
    'Party Name': order.party?.name || '',
    'Authorized Person': order.authorizedPerson,
    'Status': formatStatus(order.status),
    'Created Date': format(new Date(order.createdAt), 'dd/MM/yyyy'),
    'Valid To': format(new Date(order.validTo), 'dd/MM/yyyy'),
    'Open Issues': order.issues.filter((i: any) => i.status === 'OPEN').length,
    'Resolved Issues': order.issues.filter((i: any) => i.status === 'RESOLVED').length,
    'Created By': order.createdBy?.username || '',
    'Notes': order.notes || '',
  }));

  // Create summary data
  const summaryData = [
    ['Delivery Order Report'],
    ['Generated Date', format(new Date(), 'dd/MM/yyyy HH:mm')],
    ['Generated By', user.username],
    [''],
    ['Summary Statistics'],
    ['Total Orders', deliveryOrders.length],
    ['Orders with Issues', deliveryOrders.filter(o => o.issues.length > 0).length],
    ['Completed Orders', deliveryOrders.filter(o => o.status === 'at_road_sale').length],
    [''],
  ];

  // Create workbook
  const wb = XLSX.utils.book_new();
  
  // Add summary sheet
  const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
  XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');
  
  // Add details sheet
  const detailsWs = XLSX.utils.json_to_sheet(excelData);
  XLSX.utils.book_append_sheet(wb, detailsWs, 'Delivery Orders');

  // Generate buffer
  const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'buffer' });

  // Return response
  return new NextResponse(excelBuffer, {
    headers: {
      'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'Content-Disposition': `attachment; filename="DO-Report-${format(new Date(), 'yyyy-MM-dd')}.xlsx"`,
    },
  });
}

function exportToPDF(deliveryOrders: any[], user: any) {
  // For PDF, we'll return a simple HTML that can be printed as PDF
  // In production, you might want to use a library like puppeteer or jsPDF
  
  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Delivery Order Report</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { color: #333; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .header { margin-bottom: 30px; }
        .summary { margin: 20px 0; }
        .summary-item { margin: 10px 0; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Delivery Order Report</h1>
        <p>Generated on: ${format(new Date(), 'dd/MM/yyyy HH:mm')}</p>
        <p>Generated by: ${user.username}</p>
      </div>
      
      <div class="summary">
        <h2>Summary</h2>
        <div class="summary-item">Total Orders: ${deliveryOrders.length}</div>
        <div class="summary-item">Completed: ${deliveryOrders.filter(o => o.status === 'at_road_sale').length}</div>
        <div class="summary-item">With Issues: ${deliveryOrders.filter(o => o.issues.length > 0).length}</div>
      </div>
      
      <h2>Delivery Orders</h2>
      <table>
        <thead>
          <tr>
            <th>DO Number</th>
            <th>Party</th>
            <th>Authorized Person</th>
            <th>Status</th>
            <th>Created Date</th>
            <th>Issues</th>
          </tr>
        </thead>
        <tbody>
          ${deliveryOrders.map(order => `
            <tr>
              <td>${order.doNumber}</td>
              <td>${order.party?.name || ''}</td>
              <td>${order.authorizedPerson}</td>
              <td>${formatStatus(order.status)}</td>
              <td>${format(new Date(order.createdAt), 'dd/MM/yyyy')}</td>
              <td>${order.issues.length} issues</td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    </body>
    </html>
  `;

  return new NextResponse(html, {
    headers: {
      'Content-Type': 'text/html',
      'Content-Disposition': `attachment; filename="DO-Report-${format(new Date(), 'yyyy-MM-dd')}.pdf"`,
    },
  });
}

function formatStatus(status: string): string {
  return status.split('_').map(word => 
    word.charAt(0).toUpperCase() + word.slice(1)
  ).join(' ');
}