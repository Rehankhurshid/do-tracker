import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';
import { verifyToken } from '@/lib/auth';
import { format } from 'date-fns';
import * as XLSX from 'xlsx';

export async function GET(request: NextRequest) {
  try {
    const token = request.cookies.get('token')?.value;

    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const payload = verifyToken(token);
    if (!payload) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 });
    }

    // Get query parameters
    const searchParams = request.nextUrl.searchParams;
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');
    const status = searchParams.get('status');
    const partyId = searchParams.get('partyId');
    const exportFormat = searchParams.get('format') || 'excel';

    // Build Supabase query with filters
    let query = supabase
      .from('DeliveryOrder')
      .select(`
        *,
        party:Party(*),
        createdBy:User!createdById (username, email),
        issues:Issue (*,
          reportedBy:User!reportedById (username)
        )
      `)
      .order('createdAt', { ascending: false });

    // Role-based filtering - Department-wide visibility
    if (payload.role === 'AREA_OFFICE') {
      query = query.in('status', ['created', 'at_area_office']);
    } else if (payload.role === 'PROJECT_OFFICE') {
      query = query.in('status', ['at_project_office', 'received_at_project_office', 'at_road_sale']);
    } else if (payload.role === 'CISF') {
      query = query.or('status.in.(at_project_office,received_at_project_office),cisfApproved.eq.true');
    } else if (payload.role === 'ROAD_SALE') {
      query = query.eq('status', 'at_road_sale');
    }

    // Date range filter
    if (startDate && endDate) {
      const startIso = new Date(startDate).toISOString();
      const endIso = new Date(endDate + 'T23:59:59.999Z').toISOString();
      query = query.gte('createdAt', startIso).lte('createdAt', endIso);
    }

    // Status filter
    if (status && status !== 'all') {
      query = query.eq('status', status);
    }

    // Party filter
    if (partyId && partyId !== 'all') {
      query = query.eq('partyId', partyId);
    }

    const { data: deliveryOrders, error } = await query;
    if (error) {
      console.error('Supabase export reports query error:', error);
      return NextResponse.json({ error: 'Failed to export report' }, { status: 500 });
    }

    if (exportFormat === 'excel') {
  return exportToExcel(deliveryOrders || [], payload);
    } else {
  return exportToPDF(deliveryOrders || [], payload);
    }
  } catch (error) {
    console.error('Error exporting report:', error);
    return NextResponse.json(
      { error: 'Failed to export report' },
      { status: 500 }
    );
  }
}

type IssueLite = { status: 'OPEN' | 'RESOLVED' };
type PartyLite = { id: string; name: string };
type OrderLite = {
  doNumber: string;
  party?: PartyLite | null;
  authorizedPerson: string;
  status: string;
  createdAt: string;
  validTo: string;
  issues: IssueLite[];
  createdBy?: { username?: string | null } | null;
  notes?: string | null;
};
type UserLite = { username: string };

function exportToExcel(deliveryOrders: OrderLite[], user: UserLite) {
  // Prepare data for Excel
  const excelData = deliveryOrders.map(order => ({
    'DO Number': order.doNumber,
    'Party Name': order.party?.name || '',
    'Authorized Person': order.authorizedPerson,
    'Status': formatStatus(order.status),
    'Created Date': format(new Date(order.createdAt), 'dd/MM/yyyy'),
    'Valid To': format(new Date(order.validTo), 'dd/MM/yyyy'),
  'Open Issues': order.issues.filter((i: IssueLite) => i.status === 'OPEN').length,
  'Resolved Issues': order.issues.filter((i: IssueLite) => i.status === 'RESOLVED').length,
    'Created By': order.createdBy?.username || '',
    'Notes': order.notes || '',
  }));

  // Create summary data
  const summaryData = [
    ['Delivery Order Report'],
    ['Generated Date', format(new Date(), 'dd/MM/yyyy HH:mm')],
    ['Generated By', user.username],
    [''],
    ['Summary Statistics'],
    ['Total Orders', deliveryOrders.length],
    ['Orders with Issues', deliveryOrders.filter(o => o.issues.length > 0).length],
    ['Completed Orders', deliveryOrders.filter(o => o.status === 'at_road_sale').length],
    [''],
  ];

  // Create workbook
  const wb = XLSX.utils.book_new();
  
  // Add summary sheet
  const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
  XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');
  
  // Add details sheet
  const detailsWs = XLSX.utils.json_to_sheet(excelData);
  XLSX.utils.book_append_sheet(wb, detailsWs, 'Delivery Orders');

  // Generate buffer
  const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'buffer' });

  // Return response
  return new NextResponse(excelBuffer, {
    headers: {
      'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'Content-Disposition': `attachment; filename="DO-Report-${format(new Date(), 'yyyy-MM-dd')}.xlsx"`,
    },
  });
}

function exportToPDF(deliveryOrders: OrderLite[], user: UserLite) {
  // For PDF, we'll return a simple HTML that can be printed as PDF
  // In production, you might want to use a library like puppeteer or jsPDF
  
  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Delivery Order Report</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { color: #333; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .header { margin-bottom: 30px; }
        .summary { margin: 20px 0; }
        .summary-item { margin: 10px 0; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Delivery Order Report</h1>
        <p>Generated on: ${format(new Date(), 'dd/MM/yyyy HH:mm')}</p>
        <p>Generated by: ${user.username}</p>
      </div>
      
      <div class="summary">
        <h2>Summary</h2>
        <div class="summary-item">Total Orders: ${deliveryOrders.length}</div>
        <div class="summary-item">Completed: ${deliveryOrders.filter(o => o.status === 'at_road_sale').length}</div>
        <div class="summary-item">With Issues: ${deliveryOrders.filter(o => o.issues.length > 0).length}</div>
      </div>
      
      <h2>Delivery Orders</h2>
      <table>
        <thead>
          <tr>
            <th>DO Number</th>
            <th>Party</th>
            <th>Authorized Person</th>
            <th>Status</th>
            <th>Created Date</th>
            <th>Issues</th>
          </tr>
        </thead>
        <tbody>
          ${deliveryOrders.map(order => `
            <tr>
              <td>${order.doNumber}</td>
              <td>${order.party?.name || ''}</td>
              <td>${order.authorizedPerson}</td>
              <td>${formatStatus(order.status)}</td>
              <td>${format(new Date(order.createdAt), 'dd/MM/yyyy')}</td>
              <td>${order.issues.length} issues</td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    </body>
    </html>
  `;

  return new NextResponse(html, {
    headers: {
      'Content-Type': 'text/html',
      'Content-Disposition': `attachment; filename="DO-Report-${format(new Date(), 'yyyy-MM-dd')}.pdf"`,
    },
  });
}

function formatStatus(status: string): string {
  return status.split('_').map(word => 
    word.charAt(0).toUpperCase() + word.slice(1)
  ).join(' ');
}